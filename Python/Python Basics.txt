Variables:
defining a variable:
num = 123

Python data bases: 
    Numeric data bases: 
        - int
        - float
        - complex numbers

    String:
        a sequence of chars, definded by quotation marks. Example:
        name = "Nadav"
        
        String Functions:
        print(f"{name}") -> will print Nadav. This is called an f-string, and it is used for using variables inside strings in a more comfortable manner.

    Booleans:
        True or false.

    Lists: 
        Quite literally, a list of items. The items have an order and are contained in the data type called a list. The list is defined with hard brackets. Example:
        lst=["item1","item2","item3"]

        List Functions:
        lst[i] - returns the value in location i
        len(lst) - returns the length of the list
        lst.append(var) - pushed the object into place 0 in the list and pushed the other objects respectfully.
        lst.remove(var) - removes the object from the list
        lastItem=lst.pop() - assigns the value of the last item from the list to lastItem and deletes it from lst.
        print ([1,2]+[3]) -> [1,2,3]
        print (1 in [1,2,3]) -> True
        lst[x:y] -> Returns a list that consists of lst's items from index x to the yth index. (If lst=[1,2,3,4,5], lst[0:3] returns [1,2,3])
        max(lst) - returs the highest value in the list.
        min(lst) - returns the lowest value in the list.
        sorted(lst) - sorts the list from smallest to biggest.
        sum(lst) - returns the sum of the list, relevant to numbers. 
        L = list(str) - turns string into a list
        str = "".join(list) - turns a list into a string

    Tuples:
        Basically a const list, defined with parentheses.
        tup = ("item1", "item2", "item3")
        Tupels cant be appended, removed or popped. The only way to add or remove items from them is to create a new one and to add or remove items from it.
        A tuple will always maintain its order, as opposed to other data types.

    Sets:
        Similar to lists and items in the sense they have lists of items. They are mutable and fore unique data, meaning you can't have duplicates of the same item in the set. Defined with curly brackets. 
        set={"value1","value2","value3"}
        Sets dont keep the order of the values.
        set.add("value4") -> adds value4 to the set. It's add and not append because it doesnt insert it to a specific place, since it doesn't keep an order.

    Dictionaries:
        dictName={
            "key1":"value1",
            "key2':"value2",
            "key3":"value3"
        }
        print(dictName["key1"]) -> Will print "value1".
        dictName["key4"]="value4" -> Adds a new key to the dictionary and assigns a value to it.
        del dictName["key4"] -> Deletes the key from the dictionary.
        dictName.keys() -> Returns a list of the keys in the dictionary.
        dictName.values() -> Returns a list of the values in the dictionary.
        dictName.get(insertedKey) -> receives a key and returns the value of the key givem, in this case the variable "insertedKey". Returns None in case of invalid key.
        dictName.items() -> Returns a list of the dictionary content in the form of [("key1","value1"),("key2","value2"),("key3","value3")].

    None: 
        None.

Files:
with open("file_name.txt","w") as f:
    f.write("text") -> Writes to the file
with open ("file_name.txt", "r") as f:
    print (type(f))

Comparison Operators:
    =, ==, <, >, <=, >=, blah blah blah.
    New thing! the is operator. Looks for the exact value compared. Example: 
    
    var = None
    if var == None -> Checks for equaity between the values.
    if var is None -> Looks for an exact location in the memory dedicated to the value of var, something that is literally the exact same thing.

Loops:
    - For: 
        for item in sequence:
            ...
        Unpacking a tuple of tupels:
            people = (
                (22,"Nadav"),
                (24,"Rom"),
                (23,"Yonatan")
            )
            print(people)
            for age, name in people:
                print (f"{name} is {age} years old")
        Unpacking a dictionary:
            nadav={
                "Age":22,
                "Job":"Medic and security guard",
                "Currently on":"A train"
            }
            nadavTuple=nadav.items()
            for key,value in nadavTuple:
                print(f"{key}: {value}")
    - While:
        while condition:
            ...
    - Break and Continue:
        Continue - Skips the remainder of the iteration and starts a new one.
        Break - Breaks out of the loop
     
Helpful Operators:
    - in - A way to check whether an item is in a sequence. Example:
        if str in longerStr:
            pass 
    - enumerate - A way to get the loop iteration number. Example:
        for index,item in enumerate(lst):
            print(index+1,item) -> Will print the index (+1 because it starts from 0) and the item in the list.
    - Zipping - A way to merge 2 lists together into a paired tuple. Example:
        list1=['a','b','c']
        list2=[1,2,3]
        for letter,number in zip(list1,list2):
            print(letter,"=>",number). 
                   -> Will print: 
                   a => 1
                   b => 2
                   c => 3 
    - min(lst) - Returns the minimal value in the list
    - max(lst) - Returns the maximal value in the list
    - join() - Joins together items in a list with the string before, making a string. Example:
        list=['a','b','c']
        print("->".join(list)) -> prints a->b->c
    - split() - The opposite of join. Example:
        sentence = "I eat a banana"
        words = sentence.split(" ")
        print(words) -> will print ["I", "eat", "a", "banana"]
    - from random import shuffle 
      shuffle(words) - shuffles the list

List Comprehensions:
    str = "Chair on the floor"
    strLst=[letter for letter in str]
    print(strLst) -> prints ['C', 'h', 'a', 'i', 'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'f', 'l', 'o', 'o', 'r']    

    strLst=[letter for letter in str if letter.lower() in "chair"]
    print(strLst) -> prints ['C', 'h', 'a', 'i', 'r', 'h', 'r']